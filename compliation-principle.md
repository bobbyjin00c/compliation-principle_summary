# Compliation Principle

## 重点记忆
- LR(0): 仅依赖当前状态决定移进还是规约,无条件归约
- SLR(1): LR(0)基础上引入FOLLOW集限制规约动作，当下一个输入符号∈FOLLOW(A)才允许A-> α
- LR(1):在计算DFA时为每个产生式单独添加向前看符号，防止过度规约的同时更加严格，仅当输入符号=a才能归约
- LALR(1)：对具有不同向前看符号的相同产生式进行合并得到公共产生式，可能因为合并状态产生冲突，只能有归约-归约冲突

Chomsky文法：
0型：所有产生式，无限制
1型：上下文有关文法：左部小于等于右部
2型：上下文无关文法：左部为1个字符，右部多个
3型：正规文法：右边一定要有一个终结符，可以一个终结符跟着一个非终结符

若文法G是LL(1)则要满足没有左递归也没有左公共表达式
对任意产生式 A → α | β：FIRST(α) ∩ FIRST(β) = ∅
​​若 ε ∈ FIRST(α)，则还须满足​​：FIRST(β) ∩ FOLLOW(A) = ∅
确保分析器仅凭一个向前看符号即可唯一选择产生式

活前缀：
规范句型的某个前缀，不包含句柄右侧的符号，是移进-规约分析中可能出现的符号串
如：句型aacBb,句柄为cB,活前缀为ε，a,aa,aac,aacB

处理 S → if (B) S1 时：
​​B.true​​：布尔表达式 B 为真时跳转的目标地址（即 S1 的入口地址）。
​​S.next​​：S 执行完毕后的跳转地址（即 if 语句后的代码入口）。
​​示例​​：生成中间代码时，B.true 指向 S1 的首条指令，S.next 指向 if 后的下一条指令。

写词法分析表的时候，注意ACTION列数为n+1(需要加上终止符$)，GOTO还是m

DAG优化：
常量传播
常量折叠
删除公共表达式
复写传播

消除死代码
注意活跃变量不能删除

## chapter2 语言文法
符号（方幂、乘积、闭包）
语言
文法（V_n, V_t, P, S）
文法简化：只写终结符与非终结符
推导：v=*> w v推导出w
归约：推导的逆
最右推导：规范推导 最左规约 规范规约
语法树（V-n,V-t,P,S）
二义性 一个句子有多棵树
句柄：一个句型的最左直接短语 短语 直接短语 句柄
有害规则：无用，引发二义性
多余规则：不可到达，不可终止

0，1，2，3型文法区分
所有都是0
（上下文有关文法）左部长度小于等于右部 1
（上下文无关文法）左部只有一个字符，右部有多个字符 2
（正规文法）产生式形式仅局限于右部只有终结符或终结符+非终结符 3
一个正规文法一定有一个正则表达式与之等价

最右推导是规范推导 
最左规约是规范规约
句柄 直接短语 短语

## chapter3 词法分析

报错：token符合词法规则
什么错误是词法分析报错（eg.标识符命名出错）、表达式（正则表达式=正规文法=有穷自动机，即一定都找得到）

正则表达式（3型文法）
正则集L  e.g.正规式r的正则集L(r) 
正则式规则 正则表达式
算符优先级：( ) > * > · > | (状态指示· 与 或符号| 为左结合)

（a|b）*与（a*b*）*等价 

通过标识符/数字/二进制写正则表达式：
    C语言中标识符：(_|letter)(_|letter|digit)*
    C语言中十进制数字正则表达式：0|([1-9][0-9]*)
    2的倍数二进制正则表达式：（0|1）*0

转换图
    有穷自动机FA:具有用穷个中燃i的程序，唯一开始状态与一或多个终止状态
    正则表达式-> FA
    DFA确定的有穷自动机，只有一种状态，没有ε转移
    NFA不确定的有穷自动机，有多种状态，多条路径，只要有一种到达就认为接收，有多个可能的跳转
    题型：
    语言表示 -> 正则表达式 -> ε-NFA（多种状态） -> DFA（一种状态） ->DFA化简
    在NFA-> DFA这里采用 ε-closure进行转换
    DFA化简采用状态转移矩阵，一步一步划分


## chapter4 语法分析

改写文法(LL(1))：
提取左公因子：形式：A -> αβ | αγ 等价变换为 A -> α（β|γ）


消除左递归： 形式：A ->A α|β  A -> βA’ A’ -> αA’|ε


消除二义性：改写文法

消除ε产生式

自顶向下语法分析（推导）
LL(1)分析
需要考虑：
对于A -> α|β，FIRST(α)∩FIRET(β)=∅
LL(1)仅凭一个向前看符号即可唯一选择产生式，不能用左公因子

若ε∈FIRST(α)，则FIRST(β)∩FOLLOW(A)=∅
当α推导为空时确保β的起始符号不会与A的后继符号冲突
如：
A → ε | aB，且 FOLLOW(A) = {c}。
若 FIRST(aB) = {a} 与 FOLLOW(A) = {c} 无交集，则合法；否则冲突

LL(1)操作：
1.FIRST集：
对于起始非终结符（S），如S->ABd,是由A的FIRST集去掉ε确定的，若A能推出ε，再往后并上B的，类推
对于A,B就是他右部第一个字符（终结符，对于非终结符加上他的FIRST集），若是ε再加上后面的非终结符的FIRST集

2.FOLLOW集：
S的FOLLOW集只有$,别的非终结符的$也只能从S中推出
对于其他非终结符A:
    1.A在规则右部末端，如S->...A，将S的FOLLOW集写入A的
    2.A在规则右部后面跟终结符，将终结符写进去
    3.A在规则右部跟非终结符B,将FIRST(B)写入FOLLOW(A)不带ε，ε只能从S得到

3.写文法预测表
4.写表格： 步骤 符号栈$S  输入符号串 ....$ 动作（表达式，匹配，acc,err）

自底而上语法分析（归约）
L:从左到右扫描输入串 R:最右归约 （K）向前看符号个数
LR(0)：仅依赖当前状态决定移进还是规约，无条件归约

SLR(1): LR(0)加上FOLLOW集，限制规约动作，使用整个FOLLOW集，当下一个输入符号属于FOLLOW(A)才允许A->α

LR(1): 引入向前看符号，针对每个产生式单独计算可能的向前看符号，防止过度规约且更加严格，仅当输入符号=a才能规约

LALR(1): 合并具有相同核心（LR(0)）但有不同向前看符号（LR(1)）状态，可能因合并状态产生冲突，LALR只会有归约-归约冲突

## chapter5 语法制导翻译

SDD：语法制导定义是一个上下文无关文法（2型文法）和属性及语义规则的集合；又称属性文法

S-属性 综合属性：数据由子节点流向父节点；计算依赖子节点；应用（归约LR）表达式求值
（所有属性都是syn,属性值只有子节点计算并传到父节点）

L-属性 继承属性：数据由父/兄节点流向子节点；计算依赖父兄节点；应用（推导LL）代码生成
（允许综合属性+继承属性inh（必须只依赖父节点或左兄弟节点的属性））

判断技巧：属性文法中，全是s,就是综合属性；若有i，i在文法左部（父）或运算符左边（左兄）；如A.s=B.s+C.s,  D.i(父i)=A.i(左兄i)+B.s

注释语法分析树，从digit.lexual（叶子）往上反推

SDD求值顺序：
依赖图：对文法属性标序号，在语法分析树中用有向虚线和序号指出推导流程（拓扑排序）

抽象语法树AST：提出无关语法细节，分号括号等

## chapter6 中间代码生成

输入：语法树 输出：中间表示IR
IR形式：三地址码TAC
【TAC指令】
·x=y op z 	二元运算（+-*/）
·x=op y		y一元运算，对有=y进行op运算后存入x
·x=y		赋值
·goto L		转到标签L（常见于if-else 与while）
·if x relop y goto L		条件跳转到标签（relop > < >= <=比较运算符）
·param x	参数传递，将x压入参数栈
·call f,n		调用函数f,含有n个参数（参数由之前的param x来顺序压入）
·return x	返回x值
·Label L		定义标签L,标签代表一个位置，gotoL可以跳转到定义L的位置
·array x=y[z]	数组访问，取y[z]值赋给x
·y[z]=x		数组定义，将x值存入y[z]
·minus		取负数，t=minus a t=-a

四元式 相较于三元式多了结果：step 指令op 参与运算arg1 参与运算arg2 结果res

高级中间表示：
AST 抽象树 只保留变量和符号 （见草稿例子）
DAG 有向无环图 多个相同变量合并：为每一个运算符号op标号，如1+，2+等，视其计算式为一个整体，逐渐加东西直到得到整个计算式，列出表：序号 id(运算符) i(参数)

表达式类型 （类型、类名、构造算子）
构造算子：
Array() record()  e.g. T-> BC| record{D}  T生成基本类型/记录类型
B -> int|double 	 T生成int或double类型

·带偏移量（字节数）int 4字节，double 8字节
e.g. x=a[i]+b[j]
TAC:    t1=i*4  //整型占4字节，在同一行内第i个元素偏移量为4*i）
        t2=a[t1] 
        t3=j*4 
        t4=b[t3] 
        t5=t2+t4 
        x=t5

e.g. 2.x=a[i][j]+b[i][j] a,b均为2*3整型数组
TAC:    t1=i*12  //a[2][3]二行三列，每行总字节数3*4=12,行i*12 列j*4
        t2=j*4      
        t3=t1+t2    // t3=t1+t2的原因：二维数组内存按照行连续存储
        t4=a[t3]
        ...

类型检查：
强类型：不允许隐式转换（x=10,y=”20”,z=x+int(y)）
弱类型：允许隐式转换（x=10,y-20,z=x+y，输出“1020”）
短路计算：布尔表达式计算一部分就能得到结果，无需对整个式子完全计算
        While(i<10&&(j>0||k==5)){
        i++;j--;}
        Label loop:
        If i>=10 goto exit
        If j>0 goto body
        If k!=5 goto loop
        Label body:
        I=i+1;
        J=j-1;
        Goto loop;
        Label exit 

回填backpatching
翻译：if(A&&B) {S;} 为TAC
    步骤：
    1.生成A代码
    2.生成B代码
    3.合并
    4.回填A
    5.生成S代码

    最终得到： 	100	 if A goto 102
    101	 goto 106
    102 	if B goto 106
    103 	goto 106
    104 	S
    105	 goto 106
    106 	goto 106

## chapter8 目标代码生成
【指令】
- LD a,b
- ST x,R
- OP dst, src1,src2
- OP dst,src1
- BR L //无条件跳转至L
- Bcond r,L //根据寄存器r值决定是否跳转到标签L
  
【指令中的寻址模式】开销（代价）
- C     //立即数常量，开销=1
- x     //绝对地址，开销=1
- *x    //间接地址，开销=1
- R     //直接寄存器寻址，开销=0
- *R    //间接寄存器寻址，开销=0
- a(R)  //直接变址寻址，开销=1；a为变量或常量

e.g. LD R1， 100（R2），寄存器R2的值+100得到的和指向的位置中的内容加载到R1中
e.g. LD R1，*100（R2），寄存器R2的值+100得到的和指向的位置中的内容所代表的值加载到R1中

程序与指令的代价
- 一条指令的代价 = 1+操作数寻址代价
- 一个程序的代价 = 所有指令的代价和
LD 从内存加载数据到寄存器，代价1
ST 将数据从寄存器存回内存，代价1
OP 纯寄存器操作，单周期完成，代价0
JMP 直接跳转，代价0
记得最后每一条指令都有固定一个代价


## chapter9 代码优化

等价变换得到效率更高的代码
【局部优化】local
在基本块内进行优化（基本块：顺序执行语句序列，只有一个入口+一个出口语句）
逻辑：划分基本块 -> 构造基本DAG -> DAG优化

【循环优化】loop
基于流图进行，将控制信息使用箭头加到基本块集合上，构成有向图
点集：基本块为结点，首结点包含第一条语句
边集：基本块B1 -> B2 引起有向边
    要求：B2在程序中位置紧跟B1后面，且B1的出口语句不是无条件转移或者终止语句
         B1的出口语句是转移语句（直接或条件），且转移目标为B2入口
代码外提：将循环不变运算提到循环前面，使之只在循环外计算一次
强度削弱：将运算强度大的运算替换为强度小的运算。如乘法运算 -> 加法运算
变换循环控制技术：将循环控制条件等价为另一个条件，变换后可以删减代码减少执行次数

强连通子图
自然循环：  各个节点n支配结点集D(n)从m到n一定要经过的节点构成集合
            流图中回边
            循环（对应回边）
【全局优化】global
作用于整个函数，可跨基本块
数据流分析： 变量被赋值（定义） 左值
            变量被引用（使用） 右值
            活跃性：变量在某个语句后是否被视作右值使用

<到达-定值数据流分析>

Gen[B]：基本块内新生成的定义
Kill[B]：基本块内杀死的外部定义（对外部的进行了重定义）
        kill规则:   找当前块内的在所有外部块中定义的定义语句，放入kill
                    变量在当前块中被多次重复定义，都要kill
                    变量循环执行时要kill,如 d:= a+d
                    对于多次执行每次覆盖自身的要kill（多个基本块形成一个内部循环，循环的定义要kill）
IN[B]：当前块的所有前驱块OUT[B]的并集（在初始循环中，是前驱块的OUT[B]，直接拿下来用），后续要考虑多个前驱
OUT[B]：公式计算：OUT[B]=Gen[B]∪（IN[B]-Kill[B]）实际上交并运算

操作过程：
计算初始表格后执行以下操作直到收敛（表格不在变化）
对每个B: 计算IN,OUT直到所有都不变
后续迭代：处理循环与跨块依赖
UD链：找到使用点，反找定义点
如 B4:print[z]，找z的定义点 z=x+y

<活跃变量数据流分析>
LiveUse[B]: 基本块中使用但未定义的变量
Def[B]:基本块中定义的变量
LiveOUT[B]:∪IN[S],所有前驱IN
LiveIN[B]: LiveUse∪（LiveOut - Def）

DU链：找到定义点，正向找到所有可能使用的点（与UD相反）

到达定值：UD use-define 根据使用点找定义点
活跃变量：DU define-use 根据定义点找所有可能的使用点
